---
title: Azure SQL Databases - Deploying Updates with EF Core and GitHub
date: '2024-01-26'
tags: ['entity-framework', 'azure', 'github', 'devops', 'azure-cli']
draft: false
summary:
images: ['/static/images/ef-core-8-exploring-must-know-key-features/banner.png']
layout: PostLayout
canonicalUrl: https://www.dandoescode.com/blog/ef-core-8-exploring-must-know-key-features
---

![Banner](/static/images/ef-core-8-exploring-must-know-key-features/banner.png)

<TOCInline toc={props.toc} exclude="Overview" toHeading={3} />

## Introduction

Recently, a colleague and I were working on a DB migration process in an internal project.  The easy option here is to get the application to run DB migrations during start-up.  But this adds to start-up time and can cause issues when scaling out to multiple processes.  Instead, we wanted to deploy DB schema changes during the CICD GitHub Workflow.  This is considering a good practice in the devops world, as the DB migration only happens once on deployment, and start-up times and scale-out are not affected.

However, there were a few issues we ran into along the way.  This post will cover the issues we ran into, and explore several possible solutions.

Thanks to [Matt Wicks](https://ssw.com.au/people/matt-wicks/) and [Gordon Beaming](https://ssw.com.au/people/gordon-beaming/) their helpful input on this problem.

## Pre-requisites

To follow along with this post, you will need:

- An Azure SQL Server and Database
- GitHub Repository
- Database Migrations generated by EF Core


## Process

The process we should follow for this is:

1. Workflow is triggered on push to `main`
2. Build and Test
3. Generate EF Core Migration Bundle
4. Deploy Migration Bundle to Azure SQL Database
5. Deploy Application to Azure (not covered in this article)

## Setup

To start I have a simple .NET 8 Web API with a single API to return a list of `TodoItems`.

The `TodoItem` class is defined as:

```csharp
public class TodoItem
{
    public int Id { get; set; }

    public string? Title { get; set; }

    public bool IsComplete { get; set; }

    public DateTime? DueDate { get; set; }
}
```

And I've generated a migration using the EF Core CLI:

```csharp
/// <inheritdoc />
public partial class Initial : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "TodoItems",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                Title = table.Column<string>(type: "nvarchar(max)", nullable: true),
                IsComplete = table.Column<bool>(type: "bit", nullable: false),
                DueDate = table.Column<DateTime>(type: "datetime2", nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_TodoItems", x => x.Id);
            });
    }

    /// <inheritdoc />
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(
            name: "TodoItems");
    }
}
```

Next, we need an Azure SQL Server and Database.  I've created a new Azure SQL Server and Database using the Azure Portal.  I've also created a new user and password for the database.

![Azure SQL DB](/static/images/github/azure-resources.png)

I've also got a basic GitHub Workflow setup that builds the application.

```yaml
name: .NET

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
```

## Challenge

We're now ready to start deploying our database migrations.  The first step is to generate a migration bundle.  This is a self-contained executable that contains all our migrations.  It is the recommended way to deploy migrations to production.

To generate a migration bundle in our GitHub Workflow we can leverage the EF Core CLI:

```yaml
- name: Restore Tools
  run: dotnet tool restore
- name: Build Bundle
  run: dotnet dotnet-ef migrations bundle --self-contained --force
  working-directory: ./WebApi
- name: Run Migrations
  run: ./efbundle --connection "${CONNECTION_STRING}"
  working-directory: ./WebApi
  env:
    CONNECTION_STRING: ${{ secrets.CONNECTION_STRING }}
```

*Note: In a real-world scenario, after generating the migration bundle you would save this as an artifact and execute separately during your deployment pipeline for each environment.  I'll leave this as an exercise for the reader. üòÑ*

In this project I am using a .NET Tool Manifest file.  This allows me to specify tool dependencies in my repo and restore these using `dotnet tool restore`.  Because I am using locally installed tools, I need to run `dotnet dotnet-ef` instead of `dotnet ef` to execute the EF Core CLI.

Before we can run this, we need to add the `CONNECTION_STRING` secret to our GitHub repository.  This is done in the repository settings under `Secrets`.

![GitHub Secrets](/static/images/github/repo-secret.png)

Now let's try running our workflow and see what happens.

BOOM! üí•

![GitHub Workflow Error](/static/images/github/workflow-error.png)

Due to our Azure SQL DB having a firewall, we need to add the GitHub Actions IP address to the firewall.  All other IP addresses will be denied access (this is a good thing).

## Options

We were so, close yet so far!  How can we get around the IP address issues?  Let's explore a few options.

### Option 1 - Manually Update in Azure

The first option is to manually update the firewall in the Azure Portal.

![Azure Firewall](/static/images/github/azure-networking.png)

This is a simple process, but it is not ideal.  This might work for a short amount of time, but considering the GitHub Workflow Runners execute on cloud infrastructure, the IP address will change over time.  This means we would need to manually update the firewall every time the IP address changes.

### Option 2 - Add GitHub IPs to Firewall

OK, so let's try to add all the GitHub IP's to the firewall.  GitHub expose all IPs they used via their 'meta' endpoint: https://api.github.com/meta.  We can use this to get a list of all the IPs and add them to the firewall.

We could create a PowerShell script that loops through all the IPs and adds them to the firewall.  For example:

```powershell
# Login to Azure
Connect-AzAccount

# Get the GitHub IPs
$response = Invoke-RestMethod -Uri 'https://api.github.com/meta'

# Get the Azure SQL Server
$server = Get-AzSqlServer -ServerName "<serverName>" -ResourceGroupName "<resourceGroupName>"

# Add each IP range to the firewall
foreach ($ip in $response.hooks) {
    $startIP, $endIP = $ip -split '/'
    $ruleName = $startIP -replace '\.', '_'
    New-AzSqlServerFirewallRule -ServerName $server.ServerName -ResourceGroupName $server.ResourceGroupName -FirewallRuleName $ruleName -StartIpAddress $startIP -EndIpAddress $endIP
}
```

Now, this would work, but it has a few issues:

- ‚ùå There are 4000 IP ranges in the list!  These would take a really long time to add to azure
- ‚ùå Ideally we would also clean up these IP ranges after the deployment so that's additional build minutes
- ‚ùå The IP addresses could change over time.  We can't run this script once off.  It would need to be run regularly, and possibly every workflow execution.  This would massively slow down our workflows and end up costing us a lot of precious build minutes (i.e. money ü§ë).

### Option 3 - Inspect Workflow Runner and Add IP Address

The next option is to inspect the GitHub Workflow Runner and dynamically add the IP address to the firewall.  This is similar to the previous option, but instead of adding all the IP addresses, we only add the IP address of the current runner.  This also makes it easier to clean up the firewall rules after the deployment.  Let's give it a try.

We can find out the IP address of the current runner by using the [public-ip](https://github.com/haythem/public-ip) action, and verify the IP by printing it out in the workflow:

```yaml
- name: Get Public IP
  id: ip
  uses: haythem/public-ip@v1.3
- name: Print Public IP
  run: |
    echo ${{ steps.ip.outputs.ipv4 }}
    echo ${{ steps.ip.outputs.ipv6 }}
```

Before we can add the IP address to the firewall, we need to login to Azure.  We COULD login with our own Azure credentials, but applying the principle of least privilege, we should create a new service principal with the minimum permissions required.  We can do this as follows:

```powershell
# Login to Azure CLI
az login

# Create a service principal (save the AppID and Password)
az ad sp create-for-rbac --name GitHubWorkflow

$appId = "<App ID From Above>"

# Assign the service principal the necessary permissions to manage SQL server firewall rules
az role assignment create --assignee $appID --role "SQL Security Manager"
```

*NOTE: If you have multiple subscriptions ensure you are logging into the correct subscription before creating the service principal.*

Then we have to update our workflow to login to Azure using the service principal:

```yaml
    - name: Login to Azure
      uses: azure/login@v1.6.1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
```

For this to work we need to add a new secret to our repository with the service principal credentials.  This will be in the format of:

```json
{
  "clientId": "<App ID>",
  "clientSecret": "<Password>",
  "subscriptionId": "<Subscription ID>",
  "tenantId": "<Tenant ID>"
}
```

When finished you will now have two secrets in your repository.

![GitHub Secrets](/static/images/github/repo-secret-2.png)

Now that we have our service principle and can login, we can add the firewall rule.  This can be done via:

```yaml
- name: Add IP to Firewall
  run: az sql server firewall-rule create --resource-group ${RESOURCE_GROUP} --server ${SQL_SERVER} --name GitHubIP --start-ip-address ${IP_ADDRESS} --end-ip-address ${IP_ADDRESS}
  env:
    SQL_SERVER: <Your SQL Server>
    IP_ADDRESS: ${{ steps.ip.outputs.ipv4 }}
    RESOURCE_GROUP: <Your Resource Group>
```

And of course, to be a good citizen, we should clean up the firewall rule after the deployment:

```yaml
- name: Remove IP from Firewall
  run: az sql server firewall-rule delete --resource-group ${RESOURCE_GROUP} --server ${SQL_SERVER} --name GitHubIP
  env:
    SQL_SERVER: <Your SQL Server>
    RESOURCE_GROUP: <Your Resource Group>
```

With all these changes in place our complete workflow looks like:

```yaml
name: .NET

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Restore Tools
      run: dotnet tool restore
    - name: Build Bundle
      run: dotnet dotnet-ef migrations bundle --self-contained --force
      working-directory: ./WebApi
    - name: Get Public IP
      id: ip
      uses: haythem/public-ip@v1.3
    - name: Print Public IP
      run: |
        echo ${{ steps.ip.outputs.ipv4 }}
        echo ${{ steps.ip.outputs.ipv6 }}
    - name: Login to Azure
      uses: azure/login@v1.6.1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    - name: Add IP to Firewall
      run: az sql server firewall-rule create --resource-group ${RESOURCE_GROUP} --server ${SQL_SERVER} --name GitHubIP --start-ip-address ${IP_ADDRESS} --end-ip-address ${IP_ADDRESS}
      env:
        SQL_SERVER: sql-dandoescode-azure-db-github-ef-bundles-dev
        IP_ADDRESS: ${{ steps.ip.outputs.ipv4 }}
        RESOURCE_GROUP: rg-dandoescode-azure-db-github-ef-bundles-dev
    - name: Run Migrations
      run: ./efbundle --connection "${CONNECTION_STRING}"
      working-directory: ./WebApi
      env:
        CONNECTION_STRING: ${{ secrets.CONNECTION_STRING }}
    - name: Remove IP from Firewall
      run: az sql server firewall-rule delete --resource-group ${RESOURCE_GROUP} --server ${SQL_SERVER} --name GitHubIP
      env:
        SQL_SERVER: sql-dandoescode-azure-db-github-ef-bundles-dev
        RESOURCE_GROUP: rg-dandoescode-azure-db-github-ef-bundles-dev
```

And with all this in place, our workflow runs successfully! ü•≥

![workflow-success](/static/images/github/workflow-success.png)

## Source Code

If you'd like to see the full solution used in the post, you can find it on GitHub: [github.com/danielmackay/dandoescode-azure-db-github-ef-bundles](https://github.com/danielmackay/dandoescode-azure-db-github-ef-bundles)

## Summary



## Resources

- [EF Core Docs | Migration Bundles](https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/applying?tabs=dotnet-core-cli#bundles)
- [Azure CLI | SQL Server Firewall Rules](https://learn.microsoft.com/en-us/cli/azure/sql/server/firewall-rule?view=azure-cli-latest)
- [Azure CLI | Service Principles](https://learn.microsoft.com/en-us/cli/azure/ad/sp?view=azure-cli-latest)
- [GitHub Actions | Public IP](https://github.com/haythem/public-ip)
- [GitHub Actions | Azure Login](https://github.com/marketplace/actions/azure-login)
