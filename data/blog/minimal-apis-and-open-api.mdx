---
title: Minimal APIs - Typed Results and Open API Specification
date: '2024-03-16'
tags: ['']
draft: false
summary:
images: ['/static/images/azure-sql-databases-deploying-updates-with-ef-core-and-github/banner.png']
layout: PostLayout
canonicalUrl: https://www.dandoescode.com/blog/azure-sql-databases-deploying-updates-with-ef-core-and-github
---

![Banner](/static/images/azure-sql-databases-deploying-updates-with-ef-core-and-github/banner.png)

<TOCInline toc={props.toc} exclude="Overview" toHeading={3} />

## Introduction

For web developers, building REST APIs is our bread and butter.  We use them to expose data and functionality to our clients and to integrate systems together.  However, there is no point building the most beautiful API in the world if consumers can't easily use it.

In this article we're going to look at several strategies we can use to integrate Open API (formerly Swagger) into our .NET 8 Minimal API.  We'll investigate some the pitfalls of some of these strategies, and look at how we can use Typed Results to make our APIs more consistent and easier to consume.


## Open API Specification

The Open API Specification (OAS) is a standard for documenting REST APIs.  It allows us to describe the endpoints, request and response models, and other details of our API in a machine-readable format.  This allows us to generate client libraries, documentation, and other tools to help consumers of our API.

There are generally two ways we can go about generating an OAS document for our API:

1. **Code-First**: We can use libraries like Swashbuckle to generate an OAS document from our code.  This is the most common approach, and is generally the easiest to get started with.
2. **API-First**: We can write the OAS document by hand, and then use tools like NSwag to generate the server and client code from the document.  This approach is more flexible, but can be more work to set up and maintain.

We'll be using the code-first approach.

## Setup

The following examples will be based around super heroes.  Each example will depend on a `Hero` and `HeroService` class, which we'll define as follows:

```csharp
public record Hero(string Name, string Power);

public class HeroService
{
    private readonly List<Hero> _heroes =
    [
        new Hero("Superman", "Strength"),
        new Hero("Batman", "Money"),
        new Hero("Flash", "Speed")
    ];

    public Hero? GetByName(string name) => _heroes.FirstOrDefault(h => h.Name == name);

    public void Add(Hero hero) => _heroes.Add(hero);
}
```

## Option 1 - Basic API

Creating a basic API with correct OAS documentation is pretty straight forward.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Services for API metadata
builder.Services.AddEndpointsApiExplorer();

// Services for Swashbuckle OAS
builder.Services.AddSwaggerGen();

builder.Services.AddSingleton<HeroService>();

var app = builder.Build();

// Middleware for OAS
app.UseSwagger();

// Middleware for Swagger UI
app.UseSwaggerUI();

app.UseHttpsRedirection();

// Basic API
app.MapPost("/heroes", (Hero hero, HeroService service) => { service.Add(hero); })
    .WithName("CreateHero")
    .WithOpenApi();

app.Run();
```

After running the application we can see our swagger UI that has been generated from our OAS.  It shows the `CreateHero` endpoint, and the `Hero` model, and returns the correct status code.
![basic api](/static/images/minimal-apis-and-open-api/image1.png)

The next options will be variations on this basic API.

## Option 2 - Custom Status Codes

Right now we're letting ASP.NET core infer a HTTP status code for us (200 OK).  What if we want to return a different status code (201 Created)?

```csharp
app.MapPost("/heroes", (Hero hero, HeroService service) =>
    {
        // updated ðŸ‘‡
        service.Add(hero);
        return Results.Created();
        // updated ðŸ‘†
    })
    .WithName("CreateHero")
    .WithOpenApi()
```

We can see here our API is returning a 201, but something strange is happening.  It's reporting the 201 as 'undocumented', and is still reporting a 200 can be returned (which is incorrect).

![basic api](/static/images/minimal-apis-and-open-api/image2.png)

We can fix this up by adding extra metadata to our endpoint.

```csharp
app.MapPost("/heroes", (Hero hero, HeroService service) =>
    {
        service.Add(hero);
        return Results.Created();
    })
    .WithName("CreateHero")
    .WithOpenApi()
    .Produces(StatusCodes.Status201Created); // ðŸ‘ˆ added
```

If we hit our API again we can see the 201 is now documented correctly.

![basic api](/static/images/minimal-apis-and-open-api/image3.png)

## Option 3 - Handling Global Middleware

What if we want to add a global middleware to our API?  For example, we might want to add a middleware to catch unhandled exceptions, and return a 500 Internal Server Error.  Another example is global catching of validation exceptions where we'll want to return a 400 Bad Request.  This approach is very common in many Clean Architecture templates.

For this to work we first need to add validation to our `HeroService`:




```csharp
    public void Add(Hero hero)
    {
        // ðŸ‘‡ added
        if (string.IsNullOrWhiteSpace(hero.Name))
            throw new ValidationException("Name is required");

        if (string.IsNullOrWhiteSpace(hero.Power))
            throw new ValidationException("Power is required");
        // ðŸ‘† added

        _heroes.Add(hero);
    }
```

We'll also need a custom `ValidationException`:

```csharp
public class ValidationException : Exception
{
    public ValidationException(string message) : base(message)
    {
    }
}
```

We'll need to create a global exception handler (new to .NET 8):

```csharp
internal sealed class GlobalExceptionHandler : IExceptionHandler
{
    public async ValueTask<bool> TryHandleAsync(
        HttpContext httpContext,
        Exception exception,
        CancellationToken cancellationToken)
    {
        if (exception is ValidationException)
        {
            var problemDetails = new ValidationProblemDetails()
            {
                Status = StatusCodes.Status400BadRequest,
                Title = "Bad Request",
                Detail = exception.Message
            };

            httpContext.Response.StatusCode = problemDetails.Status.Value;

            await httpContext.Response
                .WriteAsJsonAsync(problemDetails, cancellationToken);

            return true;
        }

        return false;
    }
}
```

The `GlobalExceptionHandler` will then need to be wired up in our `Program.cs`.  We'll also need to add some extra metadata to our API that documents our 404 BadRequest:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddSingleton<HeroService>();

// ðŸ‘‡ added
builder.Services.AddExceptionHandler<GlobalExceptionHandler>();
builder.Services.AddProblemDetails();
// ðŸ‘† added

var app = builder.Build();
app.UseSwagger();
app.UseSwaggerUI();
app.UseHttpsRedirection();

// API with correct metadata and global validation error handler
app.MapPost("/heroes", (Hero hero, HeroService service) =>
    {
        service.Add(hero);
        return Results.Created();
    })
    .WithName("CreateHero")
    .WithOpenApi()
    .Produces(StatusCodes.Status201Created)
    .ProducesValidationProblem(); // ðŸ‘ˆ added

app.UseExceptionHandler(); // ðŸ‘ˆ added

app.Run();
```
If we send a request with an empty `Name` or `Power` we can see our global validation handler is working correctly.  We can see a 400 Bad Request is returned, and the error message is correctly documented.

![basic api](/static/images/minimal-apis-and-open-api/image3.png)

### Using Exceptions as Flow Control

Using exceptions allows us to have global handling for certain types of errors (server error, bad request, not found, etc).  They keep our code minimal as we don't need to add specific handling into every API endpoint.  However, we we've see we still need to ensure these status code are documented correctly.

The problem with this approach is that we're using exceptions as flow control.  In other words, if a behavior is expected in your application (like a validation error), this is not an exceptional circumstance.

> Exceptions should be used only for exceptional circumstances, not for flow control.

David Fowler, a principal architect at Microsoft, has said:

![basic api](/static/images/minimal-apis-and-open-api/fowler_comment.png)

There are several problems with using exceptions as flow control:

- **Performance** - Exceptions are also very expensive to throw and catch
- **Breaks Principle of Least Astonishment** - It's not obvious what exceptions can be thrown from a method.  You need to look deep into the code.
- **Flow Control** - Exceptions are complicated goto statements
- **Exception Groups** - Exceptions can be grouped into 'expected' and 'unexpected' exceptions.  It can be difficult to know which is which.

We'll take a look at addressing this in Option 6.

## Option 4 - Typed Results

Improved version of Option 1

## Option 5 - Multiple Typed Results

## Option 6 - Typed Results + Result Pattern

## Source Code

TBC

## Summary

TBC

## Resources

TBC
